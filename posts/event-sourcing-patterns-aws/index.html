<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Scott Obert</title><link rel=stylesheet href=/css/style.css><script src=/js/npm-packages.js defer></script><script defer src=https://cloud.umami.is/script.js data-website-id=e2461896-021d-422a-b83f-624a8819309b></script></head><body><header class=site-header><div class=container><div class=header-content><div class=header-left><h1><a href=/>Scott Obert</a></h1><nav><a href=/posts/>Blog</a>
<a href=/about/>About</a></nav></div><div class=social-links><a href=https://www.linkedin.com/in/scott-obert-3a7338b/ target=_blank rel="noopener noreferrer" title="LinkedIn Profile"><svg viewBox="0 0 24 24"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853.0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601.0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144.0-2.063-.926-2.063-2.065.0-1.138.92-2.063 2.063-2.063 1.14.0 2.064.925 2.064 2.063.0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225.0H1.771C.792.0.0.774.0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2.0 22.222.0h.003z"/></svg>
<span>LinkedIn</span>
</a><a href=https://github.com/scottobert target=_blank rel="noopener noreferrer" title="GitHub Profile"><svg viewBox="0 0 24 24"><path d="M12 0C5.37.0.0 5.37.0 12c0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61-.546-1.385-1.335-1.755-1.335-1.755-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.605-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 21.795 24 17.295 24 12c0-6.63-5.37-12-12-12"/></svg>
<span>GitHub</span></a></div></div></div></header><div class=container><div class=content-layout><main class=main-content><article class=post><h1>Event Sourcing Patterns in AWS</h1><div class=post-meta><span>Dec 27, 2020</span>
<span>| Tags: AWS, Event Sourcing, Architecture, DynamoDB, EventBridge, Best Practices</span></div><div class=post-content><p>Event sourcing fundamentally changes how applications handle state management by storing every state change as an immutable event rather than maintaining current state snapshots. This architectural pattern becomes particularly powerful when implemented on AWS, where managed services provide the scalability and durability required for enterprise-grade event sourcing systems. Understanding how to leverage AWS services effectively for event sourcing can transform application architectures from brittle state-dependent systems into resilient, audit-friendly, and highly scalable solutions.</p><div class=plantuml-container><img id=plantuml-event-sourcing-aws class=plantuml-diagram>
<a id=plantuml-link-event-sourcing-aws href=# target=_blank class=plantuml-link title="Open diagram in new window"><span class=plantuml-link-icon>üîç</span></a></div><script src=/js/rawdeflate.js></script><script>function encode64(e){r="";for(i=0;i<e.length;i+=3)i+2==e.length?r+=append3bytes(e.charCodeAt(i),e.charCodeAt(i+1),0):i+1==e.length?r+=append3bytes(e.charCodeAt(i),0,0):r+=append3bytes(e.charCodeAt(i),e.charCodeAt(i+1),e.charCodeAt(i+2));return r}function append3bytes(e,t,n){return c1=e>>2,c2=(e&3)<<4|t>>4,c3=(t&15)<<2|n>>6,c4=n&63,r="",r+=encode6bit(c1&63),r+=encode6bit(c2&63),r+=encode6bit(c3&63),r+=encode6bit(c4&63),r}function encode6bit(e){return e<10?String.fromCharCode(48+e):(e-=10,e<26?String.fromCharCode(65+e):(e-=26,e<26?String.fromCharCode(97+e):(e-=26,e==0?"-":e==1?"_":"?")))}var deflater=window.SharedWorker&&new SharedWorker("/js/rawdeflate.js");deflater?(deflater.port.addEventListener("message",done_deflating,!1),deflater.port.start()):window.Worker&&(deflater=new Worker("/js/rawdeflate.js"),deflater.onmessage=done_deflating);function done_deflating(e){const s=document.getElementById("plantuml-event-sourcing-aws"),t="https://www.plantuml.com/plantuml/img/"+encode64(e.data);s.src=t;const n=document.getElementById("plantuml-link-event-sourcing-aws");n&&(n.href=t)}function compress(e){e=unescape(encodeURIComponent(e)),deflater?deflater.port&&deflater.port.postMessage?deflater.port.postMessage(e):deflater.postMessage(e):setTimeout(function(){done_deflating({data:deflate(e)})},100)}compress(`
@startuml
!theme aws-orange
title Event Sourcing Architecture on AWS

actor Client
participant "API Gateway" as API
participant "Command Handler\\n(Lambda)" as CommandHandler
database "Event Store\\n(DynamoDB)" as EventStore
queue "DynamoDB Stream" as Stream
participant "Projection Builder\\n(Lambda)" as Projector
database "Read Model\\n(DynamoDB)" as ReadModel
queue "EventBridge" as EventBridge
collections "Event Consumers" as Consumers

Client -> API: Command
activate API
API -> CommandHandler: Process Command
activate CommandHandler

CommandHandler -> CommandHandler: Validate Command
CommandHandler -> EventStore: Append Event(s)
note right: Events are the source of truth

EventStore -> Stream: Trigger Stream
Stream -> Projector: Process Event
activate Projector
Projector -> ReadModel: Update Projection
deactivate Projector

CommandHandler -> EventBridge: Publish Domain Event
EventBridge -> Consumers: Fan Out to Subscribers

CommandHandler --> API: Command Result
deactivate CommandHandler
API --> Client: Response
deactivate API

Client -> API: Query
activate API
API -> ReadModel: Read Projection
API --> Client: Query Result
deactivate API

note right of EventStore
  * Immutable event log
  * Versioned by aggregate
  * Optimistic concurrency
end note

note right of ReadModel
  * Denormalized for queries
  * Eventually consistent
  * Purpose-built views
end note
@enduml
`)</script><h2 id=the-foundation-of-event-sourcing-architecture>The Foundation of Event Sourcing Architecture</h2><p>Traditional applications typically store only the current state of entities, losing the rich history of how that state evolved over time. Event sourcing inverts this approach by treating events as the source of truth, with current state derived by replaying events from the beginning of time. This shift provides several compelling advantages: complete audit trails emerge naturally, temporal queries become possible, and debugging complex state transitions becomes significantly easier.</p><p>The immutable nature of events provides strong consistency guarantees that are particularly valuable in distributed systems. Once an event is stored, it never changes, eliminating a whole class of concurrency issues that plague traditional state-based systems. This immutability also enables powerful replay capabilities, allowing developers to recreate any historical state or test new business logic against real historical data.</p><p>AWS services align naturally with event sourcing principles. DynamoDB provides the high-throughput, low-latency storage required for event streams, while services like EventBridge and Kinesis enable real-time event processing and distribution. The serverless nature of many AWS services means that event sourcing architectures can scale automatically based on event volume without requiring complex infrastructure management.</p><h2 id=implementing-event-stores-with-dynamodb>Implementing Event Stores with DynamoDB</h2><p>DynamoDB serves as an excellent foundation for event stores due to its ability to handle high write throughput and provide strong consistency within partition boundaries. The key design decision involves structuring the partition key to enable efficient event retrieval while maintaining write scalability. A common pattern uses aggregate identifiers as partition keys, with event sequence numbers or timestamps as sort keys.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// Event store schema design for DynamoDB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>EventRecord</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>aggregateId</span>: <span style=color:#66d9ef>string</span>;        <span style=color:#75715e>// Partition key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sequenceNumber</span>: <span style=color:#66d9ef>number</span>;     <span style=color:#75715e>// Sort key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>eventType</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>eventData</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span>, <span style=color:#a6e22e>any</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timestamp</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>version</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>correlationId?</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>causationId?</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>putEventCommand</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PutItemCommand</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>TableName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;EventStore&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Item</span>: <span style=color:#66d9ef>marshall</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregateId</span>: <span style=color:#66d9ef>event.aggregateId</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sequenceNumber</span>: <span style=color:#66d9ef>event.sequenceNumber</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eventType</span>: <span style=color:#66d9ef>event.eventType</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eventData</span>: <span style=color:#66d9ef>event.eventData</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>timestamp</span>: <span style=color:#66d9ef>new</span> Date().<span style=color:#a6e22e>toISOString</span>(),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>version</span>: <span style=color:#66d9ef>event.version</span>
</span></span><span style=display:flex><span>  }),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ConditionExpression</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;attribute_not_exists(aggregateId) AND attribute_not_exists(sequenceNumber)&#39;</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Optimistic concurrency control becomes crucial in event sourcing systems to prevent conflicting events from being stored. DynamoDB&rsquo;s conditional writes provide an excellent mechanism for implementing this control. By including the expected version number in the condition expression, the system can detect and reject concurrent modifications, forcing the application to retry with updated state.</p><p>Event versioning strategies must be considered from the beginning, as event schemas will evolve over time. Rather than modifying existing event structures, new versions should be introduced alongside existing ones. This approach maintains the ability to replay historical events while supporting new functionality. DynamoDB&rsquo;s flexible schema supports this evolution naturally, allowing new fields to be added without affecting existing events.</p><p>The global secondary index capabilities of DynamoDB enable efficient querying patterns beyond simple aggregate-based retrieval. Indexes on event types, timestamps, or correlation identifiers support analytical queries and cross-aggregate event processing. These indexes must be designed carefully to avoid hot partitions, often requiring composite keys that distribute load evenly.</p><h2 id=event-processing-and-projection-building>Event Processing and Projection Building</h2><p>Read models or projections represent the query side of event sourcing architectures, providing optimized views of data for specific use cases. These projections are built by processing events and maintaining denormalized views that support efficient querying. AWS Lambda functions triggered by DynamoDB Streams provide an elegant mechanism for building and maintaining these projections in real-time.</p><p>The eventual consistency model of projection building requires careful consideration of business requirements. Some use cases can tolerate slight delays in projection updates, while others require immediate consistency. Lambda functions processing DynamoDB Streams typically achieve very low latency, often updating projections within milliseconds of event storage.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// Lambda function for building projections from events
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buildProjectionHandler</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>event</span>: <span style=color:#66d9ef>DynamoDBStreamEvent</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>documentClient</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>DynamoDBDocumentClient</span>.<span style=color:#66d9ef>from</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DynamoDBClient</span>({}));
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>record</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>Records</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>eventName</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;INSERT&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>eventData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>unmarshall</span>(<span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>dynamodb</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>NewImage</span> <span style=color:#f92672>||</span> {});
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>updateProjection</span>(<span style=color:#a6e22e>documentClient</span>, <span style=color:#a6e22e>eventData</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>updateProjection</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>client</span>: <span style=color:#66d9ef>DynamoDBDocumentClient</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>eventData</span>: <span style=color:#66d9ef>EventRecord</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>eventData</span>.<span style=color:#a6e22e>eventType</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;UserCreated&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>createUserProjection</span>(<span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>eventData</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;UserEmailUpdated&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>updateUserEmail</span>(<span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>eventData</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>`Unhandled event type: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>eventData</span>.<span style=color:#a6e22e>eventType</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Error handling in projection building requires sophisticated retry and dead letter queue strategies. Failed projection updates should not prevent other events from being processed, and the system must be able to recover from failures without losing data. AWS SQS dead letter queues combined with Lambda error handling provide robust mechanisms for managing projection failures.</p><p>Projection rebuilding capabilities are essential for event sourcing systems, as business requirements change and new projections become necessary. The ability to replay all historical events to build new projections is one of the key advantages of event sourcing. This process can be resource-intensive, so it&rsquo;s often implemented as a batch process using services like AWS Batch or Step Functions.</p><h2 id=event-distribution-and-integration-patterns>Event Distribution and Integration Patterns</h2><p>EventBridge serves as a powerful event distribution mechanism, enabling loose coupling between event producers and consumers. Events stored in the event store can be published to EventBridge, allowing multiple downstream systems to react to business events without creating tight coupling. This pattern supports complex business workflows while maintaining system boundaries.</p><p>The transformation capabilities of EventBridge enable events to be adapted for different consumer requirements without modifying the core event structure. A single business event might trigger multiple downstream processes, each receiving a customized version of the event data appropriate for their specific needs. This flexibility supports diverse integration requirements while maintaining a clean event store design.</p><p>Cross-region event replication becomes important for disaster recovery and global applications. EventBridge supports cross-region rules, enabling events to be automatically replicated to different AWS regions. This capability ensures that critical business events are preserved even in the face of regional failures, supporting robust disaster recovery strategies.</p><p>Event ordering guarantees vary depending on the distribution mechanism chosen. DynamoDB Streams maintain ordering within a partition, while EventBridge provides at-least-once delivery without strict ordering guarantees. Applications must be designed to handle potential out-of-order event delivery, often using event timestamps or sequence numbers to reconstruct proper ordering when necessary.</p><h2 id=saga-pattern-implementation>Saga Pattern Implementation</h2><p>Complex business processes that span multiple aggregates require careful coordination to maintain consistency without distributed transactions. The saga pattern provides a way to manage these long-running business processes using event sourcing, breaking complex operations into a series of smaller steps that can be individually committed or compensated.</p><p>Process managers or saga orchestrators maintain state about long-running business processes, using events to track progress and coordinate next steps. These orchestrators can be implemented as Lambda functions that respond to business events and trigger subsequent actions. The stateless nature of Lambda functions requires careful design of process state management, often using DynamoDB to persist saga state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// Saga process manager for order fulfillment
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>OrderSagaState</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>orderId</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>customerId</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>items</span>: <span style=color:#66d9ef>OrderItem</span>[];
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>status</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;pending&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;payment-processed&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;inventory-reserved&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;completed&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;failed&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>compensations</span>: <span style=color:#66d9ef>string</span>[];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleOrderCreated</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>event</span>: <span style=color:#66d9ef>OrderCreatedEvent</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sagaState</span>: <span style=color:#66d9ef>OrderSagaState</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>orderId</span>: <span style=color:#66d9ef>event.orderId</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>customerId</span>: <span style=color:#66d9ef>event.customerId</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>items</span>: <span style=color:#66d9ef>event.items</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>status</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;pending&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>compensations</span><span style=color:#f92672>:</span> []
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>persistSagaState</span>(<span style=color:#a6e22e>sagaState</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>requestPaymentProcessing</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>orderId</span>, <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>paymentDetails</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handlePaymentProcessed</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>event</span>: <span style=color:#66d9ef>PaymentProcessedEvent</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sagaState</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getSagaState</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>orderId</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sagaState</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;payment-processed&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sagaState</span>.<span style=color:#a6e22e>compensations</span>.<span style=color:#a6e22e>push</span>(<span style=color:#e6db74>&#39;refund-payment&#39;</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>persistSagaState</span>(<span style=color:#a6e22e>sagaState</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>reserveInventory</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>orderId</span>, <span style=color:#a6e22e>sagaState</span>.<span style=color:#a6e22e>items</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Compensation handling becomes critical when saga steps fail partway through execution. Each step in a saga must define its compensation action, which undoes the work performed by that step. The saga orchestrator tracks which compensations need to be executed and ensures they run in reverse order when failures occur.</p><p>Timeout handling in sagas prevents processes from hanging indefinitely when external systems become unresponsive. Step Functions provide excellent support for implementing saga timeouts, with the ability to trigger compensation workflows when steps exceed their expected duration. This capability ensures that business processes complete in reasonable timeframes even when dependencies experience issues.</p><h2 id=snapshot-strategies-for-performance>Snapshot Strategies for Performance</h2><p>While event sourcing provides complete audit trails and replay capabilities, reconstructing aggregate state by replaying thousands of events can become performance-prohibitive. Snapshot strategies provide a balance between performance and auditability by periodically storing aggregate state snapshots alongside the event stream.</p><p>Snapshot timing decisions significantly impact both performance and storage costs. Taking snapshots too frequently wastes storage space and processing time, while infrequent snapshots force longer replay times during aggregate reconstruction. A common approach takes snapshots every hundred events or after significant business milestones, providing reasonable performance while minimizing storage overhead.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// Snapshot management for aggregate reconstruction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AggregateSnapshot</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>aggregateId</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>version</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timestamp</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span>, <span style=color:#a6e22e>any</span>&gt;;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>loadAggregateWithSnapshot</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>aggregateId</span>: <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>AggregateRoot</span>&gt; <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>snapshot</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getLatestSnapshot</span>(<span style=color:#a6e22e>aggregateId</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>eventsAfterSnapshot</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getEventsSinceVersion</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregateId</span>, 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>snapshot</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>version</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aggregate</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>snapshot</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>?</span> <span style=color:#a6e22e>reconstructFromSnapshot</span>(<span style=color:#a6e22e>snapshot</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AggregateRoot</span>(<span style=color:#a6e22e>aggregateId</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>eventsAfterSnapshot</span>.<span style=color:#a6e22e>reduce</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>agg</span>, <span style=color:#a6e22e>event</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>agg</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>event</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregate</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Snapshot validation ensures that stored snapshots accurately represent the state that would be derived from event replay. This validation can be performed asynchronously by replaying events from the beginning and comparing the result with stored snapshots. Discrepancies indicate either snapshot corruption or event replay logic bugs that require investigation.</p><p>The decision of where to store snapshots depends on access patterns and consistency requirements. Storing snapshots in the same DynamoDB table as events provides strong consistency but may impact event write performance. Separate storage in S3 or a dedicated DynamoDB table provides better isolation but requires careful consistency management during snapshot creation and retrieval.</p><h2 id=security-and-compliance-considerations>Security and Compliance Considerations</h2><p>Event sourcing systems must carefully protect the immutable event stream from unauthorized modification or deletion. AWS services provide multiple layers of protection, including IAM policies that restrict write access to event stores, S3 object lock for immutable event archival, and CloudTrail logging of all access attempts.</p><p>Encryption strategies must consider both data at rest and data in transit. DynamoDB supports encryption at rest using AWS managed keys or customer-managed keys in KMS. Events containing sensitive data should be encrypted before storage, with careful key management ensuring that historical events remain accessible even as encryption keys rotate.</p><p>Compliance requirements often mandate long-term event retention with specific access controls and audit trails. S3 Glacier provides cost-effective long-term storage for historical events, while lifecycle policies can automatically transition older events from DynamoDB to archival storage. This approach maintains compliance while controlling storage costs for large event volumes.</p><p>Data privacy regulations like GDPR create unique challenges for event sourcing systems, as the immutable nature of events conflicts with requirements for data deletion. Techniques like cryptographic erasure, where encryption keys are deleted rather than the events themselves, provide a way to effectively &ldquo;forget&rdquo; data while maintaining event immutability for other purposes.</p><h2 id=monitoring-and-observability>Monitoring and Observability</h2><p>Event sourcing systems require comprehensive monitoring to ensure proper operation and identify issues before they impact business processes. CloudWatch metrics should track event write throughput, projection update latency, and error rates across all components. These metrics provide early warning of capacity issues or system failures.</p><p>Distributed tracing becomes particularly important in event sourcing architectures where a single business operation might trigger multiple events and projection updates across different services. AWS X-Ray provides excellent support for tracing requests through event sourcing workflows, helping identify bottlenecks and failure points in complex event processing chains.</p><p>Event stream health monitoring involves tracking metrics like event ordering, duplicate detection, and processing lag. Custom CloudWatch metrics can monitor the time between event creation and projection updates, alerting when eventual consistency SLAs are violated. This monitoring ensures that read models remain reasonably current with the event stream.</p><p>Alerting strategies should distinguish between transient issues that resolve automatically and systemic problems requiring immediate attention. Failed projection updates might retry automatically and succeed, while event store corruption requires immediate intervention. Sophisticated alerting rules prevent alert fatigue while ensuring critical issues receive prompt attention.</p><p>Event sourcing represents a powerful architectural pattern that becomes even more compelling when implemented using AWS managed services. The combination of DynamoDB&rsquo;s scalability, Lambda&rsquo;s event processing capabilities, and EventBridge&rsquo;s distribution features provides a robust foundation for building event-sourced systems that can scale to enterprise requirements while maintaining strong consistency and audit capabilities.</p><p>Success with event sourcing requires careful consideration of data modeling, consistency requirements, and operational concerns from the beginning of the design process. Organizations that invest in well-designed event sourcing architectures gain significant advantages in auditability, scalability, and system flexibility that pay dividends as applications evolve and grow in complexity.</p></div></article></main><aside class=blog-sidebar><div class=sidebar-widget><h3>Recent Posts</h3><ul class=recent-posts><li><a href=/posts/using-ai-in-software-engineering/>Harnessing AI in Software Engineering: Opportunities and Challenges</a>
<span class=post-date>May 29, 2025</span></li><li><a href=/posts/aws-serverless-cost-optimization/>Cost Optimization Strategies for AWS Serverless Applications</a>
<span class=post-date>Jun 17, 2023</span></li><li><a href=/posts/aws-sns-sqs-typescript/>Building Event-Driven Architectures with AWS SNS/SQS and TypeScript</a>
<span class=post-date>May 21, 2023</span></li><li><a href=/posts/securing-aws-lambda/>Securing AWS Lambda Functions: Best Practices and Implementation Guide</a>
<span class=post-date>Apr 7, 2023</span></li><li><a href=/posts/aws-step-functions-typescript/>Step Functions: Orchestrating AWS Lambda Workflows in TypeScript</a>
<span class=post-date>Mar 5, 2023</span></li></ul></div><div class=sidebar-widget><h3>Categories</h3><ul class=categories><li><a href=/categories/architecture>architecture (1)</a></li><li><a href=/categories/architecture-and-design>architecture and design (7)</a></li><li><a href=/categories/artificial-intelligence>artificial intelligence (1)</a></li><li><a href=/categories/cloud-computing>cloud computing (11)</a></li><li><a href=/categories/code-quality>code quality (1)</a></li><li><a href=/categories/cost-optimization>cost optimization (1)</a></li><li><a href=/categories/data-engineering>data engineering (2)</a></li><li><a href=/categories/database>database (1)</a></li><li><a href=/categories/debugging-and-troubleshooting>debugging and troubleshooting (1)</a></li><li><a href=/categories/development-tools>development tools (2)</a></li><li><a href=/categories/development-tutorials>development tutorials (1)</a></li><li><a href=/categories/microservices>microservices (1)</a></li><li><a href=/categories/performance>performance (1)</a></li><li><a href=/categories/quality-assurance>quality assurance (1)</a></li><li><a href=/categories/security>security (1)</a></li><li><a href=/categories/serverless>serverless (1)</a></li><li><a href=/categories/software-development>software development (8)</a></li><li><a href=/categories/technical-debt>technical debt (1)</a></li><li><a href=/categories/testing>testing (2)</a></li><li><a href=/categories/version-control>version control (1)</a></li></ul></div><div class=sidebar-widget><h3>Post Series</h3><ul class=recent-posts><li><a href=/posts/real-time-processing-architectures/>Cloud Architecture Patterns: Real-time Processing Architectures</a>
<span class=post-date>Apr 11, 2021</span><div class=series-meta><a href=/series/cloud-architecture-patterns/ class=series-link>View all 7 posts in series ‚Üí</a></div></li><li><a href=/posts/technical-debt-management-growing-codebases/>Modern Development Practices: Technical Debt Management in Growing Codebases: Strategies for Sustainable Development</a>
<span class=post-date>Dec 19, 2021</span><div class=series-meta><a href=/series/modern-development-practices/ class=series-link>View all 7 posts in series ‚Üí</a></div></li></ul></div><div class=sidebar-widget><h3>Tags</h3><div class=tag-cloud><a href=/tags/ai class=tag-cloud-item style=font-size:1rem>ai
</a><a href=/tags/api-design class=tag-cloud-item style=font-size:1rem>api design
</a><a href=/tags/architecture class=tag-cloud-item style=font-size:1rem>architecture
</a><a href=/tags/athena class=tag-cloud-item style=font-size:1rem>athena
</a><a href=/tags/automation class=tag-cloud-item style=font-size:1rem>automation
</a><a href=/tags/aws class=tag-cloud-item style=font-size:2rem>aws
</a><a href=/tags/best-practices class=tag-cloud-item style=font-size:1rem>best practices
</a><a href=/tags/chaos-engineering class=tag-cloud-item style=font-size:1rem>chaos engineering
</a><a href=/tags/ci/cd class=tag-cloud-item style=font-size:1rem>ci/cd
</a><a href=/tags/code-quality class=tag-cloud-item style=font-size:1rem>code quality
</a><a href=/tags/communication-patterns class=tag-cloud-item style=font-size:1rem>communication patterns
</a><a href=/tags/cost-optimization class=tag-cloud-item style=font-size:1rem>cost optimization
</a><a href=/tags/cqrs class=tag-cloud-item style=font-size:1rem>cqrs
</a><a href=/tags/data-architecture class=tag-cloud-item style=font-size:1rem>data architecture
</a><a href=/tags/data-lake class=tag-cloud-item style=font-size:1rem>data lake
</a><a href=/tags/data-modeling class=tag-cloud-item style=font-size:1rem>data modeling
</a><a href=/tags/database-design class=tag-cloud-item style=font-size:1rem>database design
</a><a href=/tags/debugging class=tag-cloud-item style=font-size:1rem>debugging
</a><a href=/tags/developer-tips class=tag-cloud-item style=font-size:1rem>developer tips
</a><a href=/tags/development class=tag-cloud-item style=font-size:2rem>development
</a><a href=/tags/distributed-systems class=tag-cloud-item style=font-size:1rem>distributed systems
</a><a href=/tags/dynamodb class=tag-cloud-item style=font-size:1rem>dynamodb
</a><a href=/tags/enterprise-architecture class=tag-cloud-item style=font-size:1rem>enterprise architecture
</a><a href=/tags/event-sourcing class=tag-cloud-item style=font-size:1rem>event sourcing
</a><a href=/tags/event-driven-architecture class=tag-cloud-item style=font-size:1rem>event-driven architecture
</a><a href=/tags/eventbridge class=tag-cloud-item style=font-size:1rem>eventbridge
</a><a href=/tags/fault-tolerance class=tag-cloud-item style=font-size:1rem>fault tolerance
</a><a href=/tags/glue class=tag-cloud-item style=font-size:1rem>glue
</a><a href=/tags/graphql class=tag-cloud-item style=font-size:1rem>graphql
</a><a href=/tags/kinesis class=tag-cloud-item style=font-size:1rem>kinesis
</a><a href=/tags/lambda class=tag-cloud-item style=font-size:1rem>lambda
</a><a href=/tags/load-testing class=tag-cloud-item style=font-size:1rem>load testing
</a><a href=/tags/metrics class=tag-cloud-item style=font-size:1rem>metrics
</a><a href=/tags/microservices class=tag-cloud-item style=font-size:1rem>microservices
</a><a href=/tags/monitoring class=tag-cloud-item style=font-size:1rem>monitoring
</a><a href=/tags/multi-account class=tag-cloud-item style=font-size:1rem>multi-account
</a><a href=/tags/nosql class=tag-cloud-item style=font-size:1rem>nosql
</a><a href=/tags/patterns class=tag-cloud-item style=font-size:1rem>patterns
</a><a href=/tags/performance-testing class=tag-cloud-item style=font-size:1rem>performance testing
</a><a href=/tags/productivity class=tag-cloud-item style=font-size:1rem>productivity
</a><a href=/tags/real-time class=tag-cloud-item style=font-size:1rem>real-time
</a><a href=/tags/refactoring class=tag-cloud-item style=font-size:1rem>refactoring
</a><a href=/tags/reliability class=tag-cloud-item style=font-size:1rem>reliability
</a><a href=/tags/resilience class=tag-cloud-item style=font-size:1rem>resilience
</a><a href=/tags/rest class=tag-cloud-item style=font-size:1rem>rest
</a><a href=/tags/s3 class=tag-cloud-item style=font-size:1rem>s3
</a><a href=/tags/security class=tag-cloud-item style=font-size:1rem>security
</a><a href=/tags/serverless class=tag-cloud-item style=font-size:1rem>serverless
</a><a href=/tags/software-engineering class=tag-cloud-item style=font-size:1rem>software engineering
</a><a href=/tags/standards class=tag-cloud-item style=font-size:1rem>standards
</a><a href=/tags/stream-processing class=tag-cloud-item style=font-size:1rem>stream processing
</a><a href=/tags/tdd class=tag-cloud-item style=font-size:1rem>tdd
</a><a href=/tags/technical-debt class=tag-cloud-item style=font-size:1rem>technical debt
</a><a href=/tags/testing class=tag-cloud-item style=font-size:1rem>testing
</a><a href=/tags/typescript class=tag-cloud-item style=font-size:2rem>typescript</a></div></div><div class=sidebar-widget><h3>Subscribe</h3><div class=subscribe-links><a href=/index.xml class=rss-link><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg>
RSS Feed</a></div></div><div class=sidebar-widget><h3>Archives</h3><ul class=archive-list></ul></div><div class="sidebar-widget npm-packages"><h3>My NPM Packages</h3><div id=npm-list></div></div></aside></div></div><footer class=site-footer><div class=container><p>&copy; 2025 Scott Obert</p></div></footer></body></html>