<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Scott Obert</title><link>https://scottobert.github.io/categories/security/</link><description>Recent content in Security on Scott Obert</description><generator>Hugo</generator><language>en</language><copyright>&amp;copy;2022 Scott Obert</copyright><lastBuildDate>Fri, 07 Apr 2023 13:00:00 -0700</lastBuildDate><atom:link href="https://scottobert.github.io/categories/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Securing AWS Lambda Functions: Best Practices and Implementation Guide</title><link>https://scottobert.github.io/posts/securing-aws-lambda/</link><pubDate>Fri, 07 Apr 2023 13:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/securing-aws-lambda/</guid><description>&lt;p>Following our exploration of AWS Lambda with TypeScript and Step Functions, it&amp;rsquo;s crucial to understand how to properly secure your serverless applications. Security in serverless architectures requires a different approach from traditional applications, as the infrastructure is managed by AWS while you maintain responsibility for securing your application logic and data.&lt;/p>
&lt;h2 id="understanding-the-shared-responsibility-model">Understanding the Shared Responsibility Model&lt;/h2>
&lt;p>In the AWS Lambda context, the shared responsibility model takes on a unique form. AWS handles the security of the runtime environment, execution environment isolation, and underlying infrastructure. However, developers are responsible for securing their application code, managing IAM permissions, protecting sensitive data, and ensuring secure communication between services. This division of responsibility allows you to focus on application-specific security while AWS handles the infrastructure security.&lt;/p></description></item><item><title>Threat Modeling for Cloud Applications: A Comprehensive Approach to Security Design</title><link>https://scottobert.github.io/posts/threat-modeling-cloud-applications/</link><pubDate>Sat, 19 Oct 2019 10:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/threat-modeling-cloud-applications/</guid><description>&lt;p>Threat modeling for cloud applications requires a fundamental rethinking of traditional security assessment approaches because cloud-native architectures introduce unique attack vectors, shared responsibility models, and dynamic infrastructure patterns that weren&amp;rsquo;t present in legacy systems. The distributed nature of cloud applications, combined with their rapid deployment cycles and ephemeral infrastructure components, creates a complex threat landscape that must be analyzed systematically to identify potential security vulnerabilities before they can be exploited by malicious actors.&lt;/p></description></item><item><title>Compliance Automation: Implementing Continuous Compliance in Cloud-Native Environments</title><link>https://scottobert.github.io/posts/compliance-automation/</link><pubDate>Sat, 28 Sep 2019 10:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/compliance-automation/</guid><description>&lt;p>The traditional approach to compliance, characterized by annual audits and point-in-time assessments, is fundamentally incompatible with the velocity and dynamic nature of cloud-native development practices. Modern applications deploy multiple times per day, infrastructure components scale automatically based on demand, and data flows through complex distributed systems that may span multiple cloud providers and geographic regions. This operational reality demands a new approach to compliance that can keep pace with continuous delivery while maintaining rigorous adherence to regulatory requirements.&lt;/p></description></item><item><title>Container and Serverless Security: Protecting Ephemeral Workloads</title><link>https://scottobert.github.io/posts/container-serverless-security/</link><pubDate>Sat, 07 Sep 2019 10:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/container-serverless-security/</guid><description>&lt;p>The ephemeral nature of containers and serverless functions introduces unique security challenges that traditional application security models weren&amp;rsquo;t designed to address. Unlike long-running virtual machines or physical servers, these workloads exist for minutes, hours, or even seconds, making traditional security monitoring and patching strategies ineffective. This fundamental shift requires a new approach to security that embraces the transient nature of these workloads while maintaining robust protection against evolving threats.&lt;/p>
&lt;p>Container and serverless security operates on the principle that protection must be built into the deployment pipeline rather than applied after deployment. This shift-left approach ensures that security controls are embedded throughout the development lifecycle, from image creation to runtime execution. The challenge lies in balancing security rigor with the speed and agility that containerized and serverless architectures promise to deliver.&lt;/p></description></item><item><title>API Security Best Practices for Cloud-Native Applications</title><link>https://scottobert.github.io/posts/api-security-best-practices/</link><pubDate>Sat, 17 Aug 2019 10:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/api-security-best-practices/</guid><description>&lt;p>Application Programming Interfaces (APIs) have become the fundamental building blocks of cloud-native applications, enabling microservices to communicate and external systems to integrate with internal services. However, this increased connectivity and exposure also creates significant security challenges that must be addressed through comprehensive API security strategies. Modern cloud-native applications often expose dozens or hundreds of APIs, each representing a potential attack vector that requires careful security consideration.&lt;/p>
&lt;p>The security of APIs in cloud-native environments is particularly complex because these interfaces must balance accessibility with protection, enabling legitimate users and services to interact efficiently while preventing unauthorized access and malicious activities. This challenge is compounded by the dynamic nature of cloud-native deployments, where API endpoints may be created, modified, or destroyed frequently as applications scale and evolve.&lt;/p></description></item><item><title>Secrets Management Strategies for Cloud-Native Applications</title><link>https://scottobert.github.io/posts/secrets-management-strategies/</link><pubDate>Sat, 27 Jul 2019 11:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/secrets-management-strategies/</guid><description>&lt;p>The proliferation of microservices and distributed architectures has dramatically increased the complexity of managing sensitive information in cloud-native applications. Database credentials, API keys, encryption keys, and other secrets must be securely stored, distributed, and rotated across potentially hundreds of services and environments. Traditional approaches of hardcoding secrets or storing them in configuration files are not only insecure but fundamentally incompatible with the dynamic nature of cloud-native deployments.&lt;/p>
&lt;p>Modern secrets management requires a comprehensive strategy that addresses the entire lifecycle of sensitive information, from generation and distribution to rotation and revocation. This strategy must account for the ephemeral nature of cloud-native workloads, the need for automated operations, and the security requirements of handling sensitive data across network boundaries.&lt;/p></description></item><item><title>Identity and Access Management Patterns in Cloud-Native Applications</title><link>https://scottobert.github.io/posts/identity-access-management-patterns/</link><pubDate>Sat, 06 Jul 2019 10:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/identity-access-management-patterns/</guid><description>&lt;p>Modern cloud-native applications face unprecedented challenges in managing user identities and controlling access to resources. The traditional perimeter-based security model has given way to sophisticated identity and access management (IAM) patterns that embrace the distributed nature of cloud architectures. Understanding these patterns is crucial for building secure, scalable applications that can adapt to evolving security requirements while maintaining excellent user experiences.&lt;/p>
&lt;h2 id="the-evolution-of-identity-management">The Evolution of Identity Management&lt;/h2>
&lt;p>Cloud-native applications operate in environments where traditional network boundaries have dissolved. Users access applications from various devices and locations, while applications themselves consist of numerous microservices communicating across network boundaries. This distributed architecture demands identity management solutions that can provide consistent security policies across all components while maintaining the flexibility needed for modern development practices.&lt;/p></description></item><item><title>Zero-Trust Architecture Implementation in Cloud-Native Applications</title><link>https://scottobert.github.io/posts/zero-trust-architecture-implementation/</link><pubDate>Sat, 15 Jun 2019 09:00:00 -0700</pubDate><guid>https://scottobert.github.io/posts/zero-trust-architecture-implementation/</guid><description>&lt;p>The traditional security model of &amp;ldquo;trust but verify&amp;rdquo; has become fundamentally inadequate for modern cloud-native environments. Zero-trust architecture operates on the principle that no entity—whether inside or outside the network perimeter—should be trusted by default. This paradigm shift represents a critical evolution in how we approach security design, particularly as organizations embrace distributed architectures, remote workforces, and multi-cloud strategies.&lt;/p>
&lt;p>In cloud-native applications, the concept of a network perimeter has largely dissolved. Services communicate across various networks, containers spin up and down dynamically, and data flows through multiple layers of infrastructure. Zero-trust provides a framework for securing these complex, distributed systems by treating every access request as potentially hostile and requiring explicit verification before granting access to any resource.&lt;/p></description></item></channel></rss>