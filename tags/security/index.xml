<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Scott Obert</title><link>https://scottobert.com/tags/security/</link><description>Recent content in Security on Scott Obert</description><generator>Hugo</generator><language>en</language><copyright>&amp;copy;2022 Scott Obert</copyright><lastBuildDate>Fri, 07 Apr 2023 13:00:00 -0700</lastBuildDate><atom:link href="https://scottobert.com/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Securing AWS Lambda Functions: Best Practices and Implementation Guide</title><link>https://scottobert.com/posts/securing-aws-lambda/</link><pubDate>Fri, 07 Apr 2023 13:00:00 -0700</pubDate><guid>https://scottobert.com/posts/securing-aws-lambda/</guid><description>&lt;p>Following our exploration of AWS Lambda with TypeScript and Step Functions, it&amp;rsquo;s crucial to understand how to properly secure your serverless applications. Security in serverless architectures requires a different approach from traditional applications, as the infrastructure is managed by AWS while you maintain responsibility for securing your application logic and data.&lt;/p>
&lt;h2 id="understanding-the-shared-responsibility-model">Understanding the Shared Responsibility Model&lt;/h2>
&lt;p>In the AWS Lambda context, the shared responsibility model takes on a unique form. AWS handles the security of the runtime environment, execution environment isolation, and underlying infrastructure. However, developers are responsible for securing their application code, managing IAM permissions, protecting sensitive data, and ensuring secure communication between services. This division of responsibility allows you to focus on application-specific security while AWS handles the infrastructure security.&lt;/p></description></item><item><title>Multi-Account AWS Strategies for Enterprise Applications</title><link>https://scottobert.com/posts/multi-account-aws-strategies-enterprise-applications/</link><pubDate>Sun, 06 Dec 2020 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/multi-account-aws-strategies-enterprise-applications/</guid><description>&lt;p>Enterprise organizations face unique challenges when scaling their AWS infrastructure beyond simple single-account deployments. As applications grow in complexity and regulatory requirements become more stringent, the need for sophisticated multi-account strategies becomes paramount. This exploration delves into proven patterns that enable organizations to maintain security, compliance, and operational efficiency across distributed cloud environments.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-multi-account-architecture" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-multi-account-architecture" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">🔍&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-multi-account-architecture");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-multi-account-architecture");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml\n!theme aws-orange\ntitle Multi-Account AWS Architecture Pattern\n\npackage \u0022Management Account\u0022 {\n [AWS Organizations]\n [Consolidated Billing]\n [AWS SSO]\n [CloudTrail (Org)]\n}\n\npackage \u0022Security Account\u0022 {\n [GuardDuty Master]\n [Security Hub]\n [Config Aggregator]\n [CloudTrail Logs]\n}\n\npackage \u0022Production Account\u0022 {\n [Application Services]\n [RDS Production]\n [S3 Production]\n}\n\npackage \u0022Development Account\u0022 {\n [Dev Services]\n [RDS Dev]\n [S3 Dev]\n}\n\npackage \u0022Shared Services Account\u0022 {\n [Transit Gateway]\n [DNS Resolution]\n [Centralized Logging]\n}\n\n[AWS Organizations] --\u003e [Security Account]\n[AWS Organizations] --\u003e [Production Account]\n[AWS Organizations] --\u003e [Development Account]\n[AWS Organizations] --\u003e [Shared Services Account]\n\n[Transit Gateway] --\u003e [Production Account]\n[Transit Gateway] --\u003e [Development Account]\n\n@enduml\n")
&lt;/script>
&lt;h2 id="understanding-the-multi-account-imperative">Understanding the Multi-Account Imperative&lt;/h2>
&lt;p>The traditional approach of housing all resources within a single AWS account quickly becomes untenable for enterprise applications. Security boundaries blur when development, staging, and production workloads share the same account, creating unnecessary risk exposure. Compliance frameworks often mandate strict separation of environments, making single-account architectures insufficient for regulated industries.&lt;/p></description></item><item><title>Threat Modeling for Cloud Applications: A Comprehensive Approach to Security Design</title><link>https://scottobert.com/posts/threat-modeling-cloud-applications/</link><pubDate>Sat, 19 Oct 2019 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/threat-modeling-cloud-applications/</guid><description>&lt;p>Threat modeling for cloud applications requires a fundamental rethinking of traditional security assessment approaches because cloud-native architectures introduce unique attack vectors, shared responsibility models, and dynamic infrastructure patterns that weren&amp;rsquo;t present in legacy systems. The distributed nature of cloud applications, combined with their rapid deployment cycles and ephemeral infrastructure components, creates a complex threat landscape that must be analyzed systematically to identify potential security vulnerabilities before they can be exploited by malicious actors.&lt;/p></description></item><item><title>Container and Serverless Security: Protecting Ephemeral Workloads</title><link>https://scottobert.com/posts/container-serverless-security/</link><pubDate>Sat, 07 Sep 2019 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/container-serverless-security/</guid><description>&lt;p>The ephemeral nature of containers and serverless functions introduces unique security challenges that traditional application security models weren&amp;rsquo;t designed to address. Unlike long-running virtual machines or physical servers, these workloads exist for minutes, hours, or even seconds, making traditional security monitoring and patching strategies ineffective. This fundamental shift requires a new approach to security that embraces the transient nature of these workloads while maintaining robust protection against evolving threats.&lt;/p>
&lt;p>Container and serverless security operates on the principle that protection must be built into the deployment pipeline rather than applied after deployment. This shift-left approach ensures that security controls are embedded throughout the development lifecycle, from image creation to runtime execution. The challenge lies in balancing security rigor with the speed and agility that containerized and serverless architectures promise to deliver.&lt;/p></description></item><item><title>API Security Best Practices for Cloud-Native Applications</title><link>https://scottobert.com/posts/api-security-best-practices/</link><pubDate>Sat, 17 Aug 2019 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/api-security-best-practices/</guid><description>&lt;p>Application Programming Interfaces (APIs) have become the fundamental building blocks of cloud-native applications, enabling microservices to communicate and external systems to integrate with internal services. However, this increased connectivity and exposure also creates significant security challenges that must be addressed through comprehensive API security strategies. Modern cloud-native applications often expose dozens or hundreds of APIs, each representing a potential attack vector that requires careful security consideration.&lt;/p>
&lt;p>The security of APIs in cloud-native environments is particularly complex because these interfaces must balance accessibility with protection, enabling legitimate users and services to interact efficiently while preventing unauthorized access and malicious activities. This challenge is compounded by the dynamic nature of cloud-native deployments, where API endpoints may be created, modified, or destroyed frequently as applications scale and evolve.&lt;/p></description></item><item><title>Secrets Management Strategies for Cloud-Native Applications</title><link>https://scottobert.com/posts/secrets-management-strategies/</link><pubDate>Sat, 27 Jul 2019 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/secrets-management-strategies/</guid><description>&lt;p>The proliferation of microservices and distributed architectures has dramatically increased the complexity of managing sensitive information in cloud-native applications. Database credentials, API keys, encryption keys, and other secrets must be securely stored, distributed, and rotated across potentially hundreds of services and environments. Traditional approaches of hardcoding secrets or storing them in configuration files are not only insecure but fundamentally incompatible with the dynamic nature of cloud-native deployments.&lt;/p>
&lt;p>Modern secrets management requires a comprehensive strategy that addresses the entire lifecycle of sensitive information, from generation and distribution to rotation and revocation. This strategy must account for the ephemeral nature of cloud-native workloads, the need for automated operations, and the security requirements of handling sensitive data across network boundaries.&lt;/p></description></item><item><title>Identity and Access Management Patterns in Cloud-Native Applications</title><link>https://scottobert.com/posts/identity-access-management-patterns/</link><pubDate>Sat, 06 Jul 2019 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/identity-access-management-patterns/</guid><description>&lt;p>Modern cloud-native applications face unprecedented challenges in managing user identities and controlling access to resources. The traditional perimeter-based security model has given way to sophisticated identity and access management (IAM) patterns that embrace the distributed nature of cloud architectures. Understanding these patterns is crucial for building secure, scalable applications that can adapt to evolving security requirements while maintaining excellent user experiences.&lt;/p>
&lt;h2 id="the-evolution-of-identity-management">The Evolution of Identity Management&lt;/h2>
&lt;p>Cloud-native applications operate in environments where traditional network boundaries have dissolved. Users access applications from various devices and locations, while applications themselves consist of numerous microservices communicating across network boundaries. This distributed architecture demands identity management solutions that can provide consistent security policies across all components while maintaining the flexibility needed for modern development practices.&lt;/p></description></item><item><title>Zero-Trust Architecture Implementation in Cloud-Native Applications</title><link>https://scottobert.com/posts/zero-trust-architecture-implementation/</link><pubDate>Sat, 15 Jun 2019 09:00:00 -0700</pubDate><guid>https://scottobert.com/posts/zero-trust-architecture-implementation/</guid><description>&lt;p>The traditional security model of &amp;ldquo;trust but verify&amp;rdquo; has become fundamentally inadequate for modern cloud-native environments. Zero-trust architecture operates on the principle that no entity—whether inside or outside the network perimeter—should be trusted by default. This paradigm shift represents a critical evolution in how we approach security design, particularly as organizations embrace distributed architectures, remote workforces, and multi-cloud strategies.&lt;/p>
&lt;p>In cloud-native applications, the concept of a network perimeter has largely dissolved. Services communicate across various networks, containers spin up and down dynamically, and data flows through multiple layers of infrastructure. Zero-trust provides a framework for securing these complex, distributed systems by treating every access request as potentially hostile and requiring explicit verification before granting access to any resource.&lt;/p></description></item></channel></rss>