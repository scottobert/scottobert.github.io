<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Development on Scott Obert</title><link>https://scottobert.com/tags/development/</link><description>Recent content in Development on Scott Obert</description><generator>Hugo</generator><language>en</language><copyright>&amp;copy;2022 Scott Obert</copyright><lastBuildDate>Thu, 19 Jun 2025 09:00:00 -0700</lastBuildDate><atom:link href="https://scottobert.com/tags/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Lambda-to-Lambda Calls vs. SNS Chaining in AWS: When and How to Use Each</title><link>https://scottobert.com/posts/lambda-to-lambda-vs-sns-chaining/</link><pubDate>Thu, 19 Jun 2025 09:00:00 -0700</pubDate><guid>https://scottobert.com/posts/lambda-to-lambda-vs-sns-chaining/</guid><description>&lt;p>Modern serverless architectures often require connecting multiple AWS Lambda functions. Two common patterns are direct Lambda-to-Lambda invocation and chaining via Amazon SNS. This post explains when to use each, with diagrams, CloudFormation templates, and TypeScript code for both approaches.&lt;/p>
&lt;h2 id="when-to-use-each-pattern">When to Use Each Pattern&lt;/h2>
&lt;p>Choosing between direct Lambda-to-Lambda calls and SNS chaining depends on your workflow&amp;rsquo;s requirements for coupling, reliability, and scalability. While it is technically possible to invoke one Lambda function from another, it is important to understand the implications of doing so synchronously. Synchronous Lambda-to-Lambda callsâ€”where the first function waits for a response from the secondâ€”are generally discouraged as a best practice. This is because they can lead to increased latency, higher costs, and more complex error handling, especially if the downstream Lambda experiences throttling or failures. In most cases, tightly coupled, synchronous workflows are better implemented using other AWS services such as Step Functions, which are designed for orchestrating distributed processes with built-in error handling and state management.&lt;/p></description></item><item><title>Reverting Git Commits Safely: Undoing Changes Without Losing History</title><link>https://scottobert.com/posts/reverting-git-commits-safely/</link><pubDate>Wed, 11 Jun 2025 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/reverting-git-commits-safely/</guid><description>&lt;p>When working on complex projects, you&amp;rsquo;ll inevitably encounter situations where you need to undo changes from a specific commit that&amp;rsquo;s buried several commits back in your history. Recently, I faced this exact scenario when commit &lt;code>1d814e5&lt;/code> needed to be reverted from our development branch, but it wasn&amp;rsquo;t the most recent commit. This post explores the safest and most effective ways to handle this situation.&lt;/p>
&lt;h2 id="the-challenge">The Challenge&lt;/h2>
&lt;p>Looking at a typical git reflog, you might see something like this:&lt;/p></description></item><item><title>DynamoDB with TypeScript: Type-Safe NoSQL Operations</title><link>https://scottobert.com/posts/dynamodb-typescript/</link><pubDate>Sun, 02 Jul 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/dynamodb-typescript/</guid><description>&lt;p>Working with NoSQL databases like DynamoDB can be challenging when it comes to maintaining type safety and data consistency. In this post, we&amp;rsquo;ll explore how to build robust, type-safe DynamoDB operations using TypeScript, covering everything from basic CRUD operations to advanced patterns like single-table design and transaction handling.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-dynamodb-single-table" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-dynamodb-single-table" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">ðŸ”&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-dynamodb-single-table");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-dynamodb-single-table");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml DynamoDB Single Table Design\n!define RECTANGLE class\n\npackage \u0022Single Table Design\u0022 {\n database \u0022DynamoDB Table\u0022 as table {\n rectangle \u0022Partition Key (PK)\u0022 as pk\n rectangle \u0022Sort Key (SK)\u0022 as sk\n rectangle \u0022GSI1PK\u0022 as gsi1pk\n rectangle \u0022GSI1SK\u0022 as gsi1sk\n }\n \n rectangle \u0022User Entity\u0022 as user {\n rectangle \u0022PK: USER#123\u0022 as user_pk\n rectangle \u0022SK: USER#123\u0022 as user_sk\n rectangle \u0022GSI1PK: EMAIL#user_at_domain.com\u0022 as user_gsi1pk\n rectangle \u0022Data: name, email, dept\u0022 as user_data\n }\n \n rectangle \u0022Order Entity\u0022 as order {\n rectangle \u0022PK: ORDER#456\u0022 as order_pk\n rectangle \u0022SK: ORDER#456\u0022 as order_sk\n rectangle \u0022GSI1PK: USER#123\u0022 as order_gsi1pk\n rectangle \u0022GSI1SK: ORDER#2023-07-02\u0022 as order_gsi1sk\n rectangle \u0022Data: items, total, status\u0022 as order_data\n }\n \n rectangle \u0022Product Entity\u0022 as product {\n rectangle \u0022PK: PRODUCT#789\u0022 as product_pk\n rectangle \u0022SK: PRODUCT#789\u0022 as product_sk\n rectangle \u0022GSI1PK: CATEGORY#electronics\u0022 as product_gsi1pk\n rectangle \u0022Data: name, price, stock\u0022 as product_data\n }\n}\n\ntable --\u003e user : Store\ntable --\u003e order : Store\ntable --\u003e product : Store\n\nnote right of table\n â€¢ Single table for all entities\n â€¢ Composite keys for relationships\n â€¢ GSI for access patterns\n â€¢ Type-safe operations\nend note\n\nnote bottom of user\n Access Patterns:\n â€¢ Get user by ID: PK = USER#id\n â€¢ Get user by email: GSI1PK = EMAIL#email\nend note\n\nnote bottom of order\n Access Patterns:\n â€¢ Get order by ID: PK = ORDER#id\n â€¢ Get orders by user: GSI1PK = USER#id\nend note\n@enduml\n")
&lt;/script>
&lt;h2 id="why-type-safety-matters-with-dynamodb">Why Type Safety Matters with DynamoDB&lt;/h2>
&lt;p>DynamoDB&amp;rsquo;s flexible schema brings both opportunities and challenges:&lt;/p></description></item><item><title>Building Type-Safe APIs with AWS API Gateway and TypeScript</title><link>https://scottobert.com/posts/aws-api-gateway-typescript/</link><pubDate>Sun, 11 Jun 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-api-gateway-typescript/</guid><description>&lt;p>Building robust APIs requires more than just handling HTTP requestsâ€”it demands type safety, proper validation, and clear documentation. In this post, we&amp;rsquo;ll explore how to build production-ready APIs using AWS API Gateway with TypeScript, ensuring type safety from request to response while maintaining excellent developer experience.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-api-gateway-architecture" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-api-gateway-architecture" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">ðŸ”&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-api-gateway-architecture");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-api-gateway-architecture");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml API Gateway Architecture\n!define RECTANGLE class\n\ncloud \u0022Client Applications\u0022 as clients\npackage \u0022AWS Cloud\u0022 {\n rectangle \u0022API Gateway\u0022 as apigw {\n rectangle \u0022REST API\u0022 as restapi\n rectangle \u0022Request Validation\u0022 as validation\n rectangle \u0022CORS\u0022 as cors\n }\n \n package \u0022Lambda Functions\u0022 {\n rectangle \u0022Create User\u0022 as create\n rectangle \u0022Get User\u0022 as get\n rectangle \u0022Update User\u0022 as update\n rectangle \u0022Delete User\u0022 as delete\n }\n \n database \u0022DynamoDB\u0022 as dynamo {\n rectangle \u0022Users Table\u0022 as table\n }\n}\n\nclients --\u003e restapi : HTTPS Requests\nrestapi --\u003e validation : Validate Schema\nvalidation --\u003e cors : Apply CORS\ncors --\u003e create : POST \/users\ncors --\u003e get : GET \/users\/{id}\ncors --\u003e update : PUT \/users\/{id}\ncors --\u003e delete : DELETE \/users\/{id}\n\ncreate --\u003e table : Store User\nget --\u003e table : Retrieve User\nupdate --\u003e table : Update User\ndelete --\u003e table : Remove User\n\nnote right of validation\n â€¢ Request validation\n â€¢ Type checking\n â€¢ Schema enforcement\nend note\n\nnote right of table\n â€¢ Primary Key: id\n â€¢ Attributes: name, email,\n department, timestamps\nend note\n@enduml\n")
&lt;/script>
&lt;h2 id="why-type-safe-apis-matter">Why Type-Safe APIs Matter&lt;/h2>
&lt;p>Type safety in API development provides several critical advantages:&lt;/p></description></item><item><title>Building Event-Driven Architectures with AWS SNS/SQS and TypeScript</title><link>https://scottobert.com/posts/aws-sns-sqs-typescript/</link><pubDate>Sun, 21 May 2023 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-sns-sqs-typescript/</guid><description>&lt;p>Event-driven architectures form the backbone of modern cloud applications, enabling systems to scale gracefully while maintaining loose coupling between components. This post explores how AWS SNS and SQS, combined with TypeScript&amp;rsquo;s type safety, create robust messaging patterns that handle everything from simple notifications to complex distributed workflows.&lt;/p>
&lt;h2 id="event-driven-architecture-benefits">Event-Driven Architecture Benefits&lt;/h2>
&lt;p>Event-driven systems offer compelling advantages for modern applications. &lt;strong>Loose coupling&lt;/strong> allows services to evolve independently without breaking dependencies. &lt;strong>Natural scalability&lt;/strong> emerges as components can scale based on their specific load patterns rather than system-wide peaks. &lt;strong>Resilience&lt;/strong> improves through built-in buffering and retry mechanisms that handle traffic spikes and temporary failures gracefully.&lt;/p></description></item><item><title>Securing AWS Lambda Functions: Best Practices and Implementation Guide</title><link>https://scottobert.com/posts/securing-aws-lambda/</link><pubDate>Fri, 07 Apr 2023 13:00:00 -0700</pubDate><guid>https://scottobert.com/posts/securing-aws-lambda/</guid><description>&lt;p>Following our exploration of AWS Lambda with TypeScript and Step Functions, it&amp;rsquo;s crucial to understand how to properly secure your serverless applications. Security in serverless architectures requires a different approach from traditional applications, as the infrastructure is managed by AWS while you maintain responsibility for securing your application logic and data.&lt;/p>
&lt;h2 id="understanding-the-shared-responsibility-model">Understanding the Shared Responsibility Model&lt;/h2>
&lt;p>In the AWS Lambda context, the shared responsibility model takes on a unique form. AWS handles the security of the runtime environment, execution environment isolation, and underlying infrastructure. However, developers are responsible for securing their application code, managing IAM permissions, protecting sensitive data, and ensuring secure communication between services. This division of responsibility allows you to focus on application-specific security while AWS handles the infrastructure security.&lt;/p></description></item><item><title>AWS Step Functions with TypeScript: Orchestrating Serverless Workflows</title><link>https://scottobert.com/posts/aws-step-functions-typescript/</link><pubDate>Sun, 05 Mar 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-step-functions-typescript/</guid><description>&lt;p>Building robust serverless applications often requires orchestrating multiple Lambda functions into complex workflows. AWS Step Functions provide a visual workflow service that coordinates distributed components, manages state transitions, and handles error recoveryâ€”all while maintaining the reliability and scalability that modern applications demand.&lt;/p>
&lt;h2 id="why-step-functions-with-typescript">Why Step Functions with TypeScript?&lt;/h2>
&lt;p>TypeScript brings compelling advantages to Step Functions development beyond basic type safety. &lt;strong>Workflow clarity&lt;/strong> emerges from strongly-typed state definitions that make complex logic easier to understand and maintain. &lt;strong>Error prevention&lt;/strong> occurs at compile time through type checking of state inputs and outputs. &lt;strong>Developer experience&lt;/strong> improves dramatically with IntelliSense support for AWS SDK calls and state machine definitions.&lt;/p></description></item><item><title>AWS Lambda with TypeScript: A Complete Development Guide</title><link>https://scottobert.com/posts/aws-lambda-typescript/</link><pubDate>Fri, 17 Feb 2023 13:30:32 -0700</pubDate><guid>https://scottobert.com/posts/aws-lambda-typescript/</guid><description>&lt;p>AWS Lambda represents the foundation of serverless computing, allowing you to run code without managing servers. When combined with TypeScript, Lambda functions become more maintainable, reliable, and developer-friendly. This guide will walk you through building production-ready Lambda functions with TypeScript, covering everything from setup to deployment and best practices.&lt;/p>
&lt;h2 id="why-typescript-for-lambda">Why TypeScript for Lambda?&lt;/h2>
&lt;p>TypeScript brings several compelling advantages to Lambda development. &lt;strong>Type safety&lt;/strong> catches errors at compile time rather than runtime, preventing costly production issues. &lt;strong>Enhanced developer experience&lt;/strong> includes intelligent autocomplete, refactoring support, and better tooling integration. &lt;strong>Better maintainability&lt;/strong> comes from explicit interfaces and self-documenting code that&amp;rsquo;s easier for teams to understand and modify.&lt;/p></description></item><item><title>git reset to a given commit</title><link>https://scottobert.com/posts/git-reset-to-commit/</link><pubDate>Thu, 21 Apr 2022 09:50:32 -0700</pubDate><guid>https://scottobert.com/posts/git-reset-to-commit/</guid><description>&lt;h1 id="safely-resetting-to-a-previous-commit-in-git">Safely Resetting to a Previous Commit in Git&lt;/h1>
&lt;p>When working with Git, sometimes you need to reset your working tree to a specific commit while preserving the commit history. This guide explains how to do this safely and understand what&amp;rsquo;s happening behind the scenes.&lt;/p>
&lt;h2 id="the-problem">The Problem&lt;/h2>
&lt;p>Typically, when developers want to revert to an older commit, they might reach for &lt;code>git reset --hard&lt;/code>. However, this can be dangerous as it:&lt;/p></description></item><item><title>Decompiling dotnet apps</title><link>https://scottobert.com/posts/decompiling-dotnet-apps/</link><pubDate>Tue, 12 Apr 2022 15:09:00 -0700</pubDate><guid>https://scottobert.com/posts/decompiling-dotnet-apps/</guid><description>&lt;p>Sometimes as developers we run into a legacy application that has been running in production for years when suddenly a bug surfaces. If nobody knows where the source code for that legacy application is, that can be a huge problem.&lt;/p>
&lt;h2 id="introduction-to-net-decompilation">Introduction to .NET Decompilation&lt;/h2>
&lt;p>Decompilation is the process of converting compiled .NET assemblies (DLLs or EXEs) back into readable source code. This can be incredibly useful when:&lt;/p>
&lt;ul>
&lt;li>Dealing with legacy applications without source code&lt;/li>
&lt;li>Debugging production issues where deployed code differs from source control&lt;/li>
&lt;li>Understanding third-party libraries when documentation is insufficient&lt;/li>
&lt;li>Investigating potential security issues or malware&lt;/li>
&lt;/ul>
&lt;h2 id="using-dotpeek">Using dotPeek&lt;/h2>
&lt;p>&lt;a href="https://www.jetbrains.com/decompiler/">dotPeek&lt;/a> by JetBrains is a powerful free .NET decompiler that can help solve these problems. I recently had an occasion to use it, and even without the .pdb file, it was able to decompile the code to be very close to the source code we had in source control that we knew wasn&amp;rsquo;t what was running in production.&lt;/p></description></item><item><title>Code Quality Gates: Automated Standards Enforcement</title><link>https://scottobert.com/posts/code-quality-gates-automated-standards-enforcement/</link><pubDate>Sun, 05 Sep 2021 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/code-quality-gates-automated-standards-enforcement/</guid><description>&lt;p>Code quality gates serve as automated checkpoints that prevent substandard code from progressing through your development pipeline. When implemented effectively, they maintain consistent standards across teams while accelerating development by catching issues early and reducing manual review overhead.&lt;/p>
&lt;h2 id="understanding-quality-gates">Understanding Quality Gates&lt;/h2>
&lt;p>Quality gates are automated checks that evaluate code against predefined criteria before allowing it to proceed to the next stage of development. Unlike simple linting, quality gates encompass comprehensive analysis including code coverage, complexity metrics, security vulnerabilities, and architectural compliance.&lt;/p></description></item><item><title>Test-Driven Development in TypeScript: Beyond the Basics</title><link>https://scottobert.com/posts/test-driven-development-typescript-beyond-basics/</link><pubDate>Sun, 15 Aug 2021 09:00:00 -0700</pubDate><guid>https://scottobert.com/posts/test-driven-development-typescript-beyond-basics/</guid><description>&lt;p>Test-Driven Development (TDD) has evolved significantly with modern TypeScript tooling and frameworks. While most developers understand the basic red-green-refactor cycle, mastering TDD in TypeScript requires understanding advanced patterns, effective mocking strategies, and leveraging the type system for better test design.&lt;/p>
&lt;h2 id="beyond-basic-tdd-advanced-patterns">Beyond Basic TDD: Advanced Patterns&lt;/h2>
&lt;h3 id="type-driven-test-design">Type-Driven Test Design&lt;/h3>
&lt;p>TypeScript&amp;rsquo;s type system provides unique opportunities to improve test design. Instead of just testing implementation details, we can use types to guide our test structure and ensure comprehensive coverage:&lt;/p></description></item></channel></rss>