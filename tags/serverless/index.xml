<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Serverless on Scott Obert</title><link>https://scottobert.com/tags/serverless/</link><description>Recent content in Serverless on Scott Obert</description><generator>Hugo</generator><language>en</language><copyright>&amp;copy;2022 Scott Obert</copyright><lastBuildDate>Thu, 19 Jun 2025 09:00:00 -0700</lastBuildDate><atom:link href="https://scottobert.com/tags/serverless/index.xml" rel="self" type="application/rss+xml"/><item><title>Lambda-to-Lambda Calls vs. SNS Chaining in AWS: When and How to Use Each</title><link>https://scottobert.com/posts/lambda-to-lambda-vs-sns-chaining/</link><pubDate>Thu, 19 Jun 2025 09:00:00 -0700</pubDate><guid>https://scottobert.com/posts/lambda-to-lambda-vs-sns-chaining/</guid><description>&lt;p>Modern serverless architectures often require connecting multiple AWS Lambda functions. Two common patterns are direct Lambda-to-Lambda invocation and chaining via Amazon SNS. This post explains when to use each, with diagrams, CloudFormation templates, and TypeScript code for both approaches.&lt;/p>
&lt;h2 id="when-to-use-each-pattern">When to Use Each Pattern&lt;/h2>
&lt;p>Choosing between direct Lambda-to-Lambda calls and SNS chaining depends on your workflow&amp;rsquo;s requirements for coupling, reliability, and scalability. While it is technically possible to invoke one Lambda function from another, it is important to understand the implications of doing so synchronously. Synchronous Lambda-to-Lambda calls—where the first function waits for a response from the second—are generally discouraged as a best practice. This is because they can lead to increased latency, higher costs, and more complex error handling, especially if the downstream Lambda experiences throttling or failures. In most cases, tightly coupled, synchronous workflows are better implemented using other AWS services such as Step Functions, which are designed for orchestrating distributed processes with built-in error handling and state management.&lt;/p></description></item><item><title>Real-time Applications with AWS WebSockets and TypeScript</title><link>https://scottobert.com/posts/aws-websockets-typescript/</link><pubDate>Sun, 13 Aug 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-websockets-typescript/</guid><description>&lt;p>Modern applications increasingly demand real-time capabilities—from live chat systems and collaborative editing to real-time dashboards and gaming. In this final post of our AWS and TypeScript series, we&amp;rsquo;ll explore how to build scalable real-time applications using AWS API Gateway WebSocket APIs, Lambda functions, and TypeScript to create robust, type-safe real-time communication systems.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-websocket-architecture" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-websocket-architecture" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">🔍&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-websocket-architecture");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-websocket-architecture");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml WebSocket Architecture\n!define RECTANGLE class\n\ncloud \u0022Client Applications\u0022 as clients\npackage \u0022AWS Cloud\u0022 {\n rectangle \u0022API Gateway WebSocket\u0022 as apigw {\n rectangle \u0022Connect Route\u0022 as connect\n rectangle \u0022Disconnect Route\u0022 as disconnect\n rectangle \u0022Message Routes\u0022 as routes\n }\n \n package \u0022Lambda Functions\u0022 {\n rectangle \u0022Connection Handler\u0022 as conn_handler\n rectangle \u0022Message Handler\u0022 as msg_handler\n rectangle \u0022Room Manager\u0022 as room_handler\n rectangle \u0022Broadcast Service\u0022 as broadcast\n }\n \n database \u0022DynamoDB\u0022 as dynamo {\n rectangle \u0022Connections Table\u0022 as conn_table\n rectangle \u0022Messages Table\u0022 as msg_table\n rectangle \u0022Rooms Table\u0022 as room_table\n }\n \n rectangle \u0022API Gateway Management API\u0022 as mgmt_api\n}\n\nclients \u003c--\u003e connect : WebSocket Connection\nclients \u003c--\u003e disconnect : WebSocket Disconnection\nclients \u003c--\u003e routes : Real-time Messages\n\nconnect --\u003e conn_handler : $connect\ndisconnect --\u003e conn_handler : $disconnect\nroutes --\u003e msg_handler : Custom Routes\nroutes --\u003e room_handler : Room Operations\n\nconn_handler --\u003e conn_table : Store Connection\nmsg_handler --\u003e msg_table : Store Message\nroom_handler --\u003e room_table : Manage Rooms\n\nbroadcast --\u003e mgmt_api : Send to Connections\nmgmt_api --\u003e clients : Real-time Updates\n\nnote right of apigw\n • Persistent connections\n • Bidirectional communication • Auto-scaling\n • Route-based message handling\nend note\n\nnote right of dynamo\n • Connection state storage\n • Message persistence\n • Room membership\n • TTL for cleanup\nend note\n@enduml\n")
&lt;/script>
&lt;h2 id="understanding-websocket-apis-with-aws">Understanding WebSocket APIs with AWS&lt;/h2>
&lt;p>AWS API Gateway WebSocket APIs provide a fully managed service for building real-time, bidirectional communication applications. Key advantages include:&lt;/p></description></item><item><title>AWS CDK Infrastructure as Code with TypeScript</title><link>https://scottobert.com/posts/aws-cdk-typescript/</link><pubDate>Sun, 23 Jul 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-cdk-typescript/</guid><description>&lt;p>Managing cloud infrastructure through code brings numerous advantages over manual configuration, including version control, reproducibility, and automated deployment pipelines. In this post, we&amp;rsquo;ll explore how to use AWS CDK (Cloud Development Kit) with TypeScript to create, manage, and deploy serverless applications with infrastructure that&amp;rsquo;s as maintainable and type-safe as your application code.&lt;/p>
&lt;h2 id="why-cdk-with-typescript">Why CDK with TypeScript?&lt;/h2>
&lt;p>AWS CDK offers a compelling alternative to traditional infrastructure tools by allowing you to define cloud resources using familiar programming languages. When combined with TypeScript, CDK provides compile-time type checking, intelligent code completion, and the ability to create reusable, composable infrastructure components.&lt;/p></description></item><item><title>Cost Optimization Strategies for AWS Serverless Applications</title><link>https://scottobert.com/posts/aws-serverless-cost-optimization/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://scottobert.com/posts/aws-serverless-cost-optimization/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>While serverless architectures can significantly reduce operational costs, they require thoughtful design and configuration to maximize cost efficiency. This guide explores practical strategies for optimizing costs in AWS serverless applications, based on real-world experience and proven patterns.&lt;/p>
&lt;h2 id="lambda-function-optimization">Lambda Function Optimization&lt;/h2>
&lt;h3 id="memory-and-duration-trade-offs">Memory and Duration Trade-offs&lt;/h3>
&lt;p>The relationship between Lambda memory allocation and execution duration isn&amp;rsquo;t always intuitive. Higher memory allocations often lead to faster execution times, potentially reducing overall costs. When right-sizing memory for your functions, start with the minimum required memory of 128MB and gradually increase while monitoring performance. In many cases, doubling the memory from 128MB to 256MB can cut execution time in half, resulting in lower overall costs despite the higher memory price.&lt;/p></description></item><item><title>Building Type-Safe APIs with AWS API Gateway and TypeScript</title><link>https://scottobert.com/posts/aws-api-gateway-typescript/</link><pubDate>Sun, 11 Jun 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-api-gateway-typescript/</guid><description>&lt;p>Building robust APIs requires more than just handling HTTP requests—it demands type safety, proper validation, and clear documentation. In this post, we&amp;rsquo;ll explore how to build production-ready APIs using AWS API Gateway with TypeScript, ensuring type safety from request to response while maintaining excellent developer experience.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-api-gateway-architecture" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-api-gateway-architecture" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">🔍&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-api-gateway-architecture");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-api-gateway-architecture");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml API Gateway Architecture\n!define RECTANGLE class\n\ncloud \u0022Client Applications\u0022 as clients\npackage \u0022AWS Cloud\u0022 {\n rectangle \u0022API Gateway\u0022 as apigw {\n rectangle \u0022REST API\u0022 as restapi\n rectangle \u0022Request Validation\u0022 as validation\n rectangle \u0022CORS\u0022 as cors\n }\n \n package \u0022Lambda Functions\u0022 {\n rectangle \u0022Create User\u0022 as create\n rectangle \u0022Get User\u0022 as get\n rectangle \u0022Update User\u0022 as update\n rectangle \u0022Delete User\u0022 as delete\n }\n \n database \u0022DynamoDB\u0022 as dynamo {\n rectangle \u0022Users Table\u0022 as table\n }\n}\n\nclients --\u003e restapi : HTTPS Requests\nrestapi --\u003e validation : Validate Schema\nvalidation --\u003e cors : Apply CORS\ncors --\u003e create : POST \/users\ncors --\u003e get : GET \/users\/{id}\ncors --\u003e update : PUT \/users\/{id}\ncors --\u003e delete : DELETE \/users\/{id}\n\ncreate --\u003e table : Store User\nget --\u003e table : Retrieve User\nupdate --\u003e table : Update User\ndelete --\u003e table : Remove User\n\nnote right of validation\n • Request validation\n • Type checking\n • Schema enforcement\nend note\n\nnote right of table\n • Primary Key: id\n • Attributes: name, email,\n department, timestamps\nend note\n@enduml\n")
&lt;/script>
&lt;h2 id="why-type-safe-apis-matter">Why Type-Safe APIs Matter&lt;/h2>
&lt;p>Type safety in API development provides several critical advantages:&lt;/p></description></item><item><title>Building Event-Driven Architectures with AWS SNS/SQS and TypeScript</title><link>https://scottobert.com/posts/aws-sns-sqs-typescript/</link><pubDate>Sun, 21 May 2023 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-sns-sqs-typescript/</guid><description>&lt;p>Event-driven architectures form the backbone of modern cloud applications, enabling systems to scale gracefully while maintaining loose coupling between components. This post explores how AWS SNS and SQS, combined with TypeScript&amp;rsquo;s type safety, create robust messaging patterns that handle everything from simple notifications to complex distributed workflows.&lt;/p>
&lt;h2 id="event-driven-architecture-benefits">Event-Driven Architecture Benefits&lt;/h2>
&lt;p>Event-driven systems offer compelling advantages for modern applications. &lt;strong>Loose coupling&lt;/strong> allows services to evolve independently without breaking dependencies. &lt;strong>Natural scalability&lt;/strong> emerges as components can scale based on their specific load patterns rather than system-wide peaks. &lt;strong>Resilience&lt;/strong> improves through built-in buffering and retry mechanisms that handle traffic spikes and temporary failures gracefully.&lt;/p></description></item><item><title>Securing AWS Lambda Functions: Best Practices and Implementation Guide</title><link>https://scottobert.com/posts/securing-aws-lambda/</link><pubDate>Fri, 07 Apr 2023 13:00:00 -0700</pubDate><guid>https://scottobert.com/posts/securing-aws-lambda/</guid><description>&lt;p>Following our exploration of AWS Lambda with TypeScript and Step Functions, it&amp;rsquo;s crucial to understand how to properly secure your serverless applications. Security in serverless architectures requires a different approach from traditional applications, as the infrastructure is managed by AWS while you maintain responsibility for securing your application logic and data.&lt;/p>
&lt;h2 id="understanding-the-shared-responsibility-model">Understanding the Shared Responsibility Model&lt;/h2>
&lt;p>In the AWS Lambda context, the shared responsibility model takes on a unique form. AWS handles the security of the runtime environment, execution environment isolation, and underlying infrastructure. However, developers are responsible for securing their application code, managing IAM permissions, protecting sensitive data, and ensuring secure communication between services. This division of responsibility allows you to focus on application-specific security while AWS handles the infrastructure security.&lt;/p></description></item><item><title>AWS Step Functions with TypeScript: Orchestrating Serverless Workflows</title><link>https://scottobert.com/posts/aws-step-functions-typescript/</link><pubDate>Sun, 05 Mar 2023 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/aws-step-functions-typescript/</guid><description>&lt;p>Building robust serverless applications often requires orchestrating multiple Lambda functions into complex workflows. AWS Step Functions provide a visual workflow service that coordinates distributed components, manages state transitions, and handles error recovery—all while maintaining the reliability and scalability that modern applications demand.&lt;/p>
&lt;h2 id="why-step-functions-with-typescript">Why Step Functions with TypeScript?&lt;/h2>
&lt;p>TypeScript brings compelling advantages to Step Functions development beyond basic type safety. &lt;strong>Workflow clarity&lt;/strong> emerges from strongly-typed state definitions that make complex logic easier to understand and maintain. &lt;strong>Error prevention&lt;/strong> occurs at compile time through type checking of state inputs and outputs. &lt;strong>Developer experience&lt;/strong> improves dramatically with IntelliSense support for AWS SDK calls and state machine definitions.&lt;/p></description></item><item><title>AWS Lambda with TypeScript: A Complete Development Guide</title><link>https://scottobert.com/posts/aws-lambda-typescript/</link><pubDate>Fri, 17 Feb 2023 13:30:32 -0700</pubDate><guid>https://scottobert.com/posts/aws-lambda-typescript/</guid><description>&lt;p>AWS Lambda represents the foundation of serverless computing, allowing you to run code without managing servers. When combined with TypeScript, Lambda functions become more maintainable, reliable, and developer-friendly. This guide will walk you through building production-ready Lambda functions with TypeScript, covering everything from setup to deployment and best practices.&lt;/p>
&lt;h2 id="why-typescript-for-lambda">Why TypeScript for Lambda?&lt;/h2>
&lt;p>TypeScript brings several compelling advantages to Lambda development. &lt;strong>Type safety&lt;/strong> catches errors at compile time rather than runtime, preventing costly production issues. &lt;strong>Enhanced developer experience&lt;/strong> includes intelligent autocomplete, refactoring support, and better tooling integration. &lt;strong>Better maintainability&lt;/strong> comes from explicit interfaces and self-documenting code that&amp;rsquo;s easier for teams to understand and modify.&lt;/p></description></item><item><title>Database Design for Serverless Applications: NoSQL Patterns and Data Modeling</title><link>https://scottobert.com/posts/database-design-serverless-applications/</link><pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate><guid>https://scottobert.com/posts/database-design-serverless-applications/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In our Modern Development Practices series, we&amp;rsquo;ve covered test-driven development, code quality gates, API design patterns, and microservices communication. Today, we&amp;rsquo;re diving into database design for serverless applications – a critical aspect that can make or break your application&amp;rsquo;s performance, scalability, and cost-effectiveness.&lt;/p>
&lt;p>Serverless applications demand a different approach to data storage. Traditional relational database patterns often don&amp;rsquo;t align with the ephemeral, stateless nature of serverless functions. Instead, we need to embrace NoSQL patterns, denormalization strategies, and event-driven data synchronization.&lt;/p></description></item><item><title>Container and Serverless Security: Protecting Ephemeral Workloads</title><link>https://scottobert.com/posts/container-serverless-security/</link><pubDate>Sat, 07 Sep 2019 10:00:00 -0700</pubDate><guid>https://scottobert.com/posts/container-serverless-security/</guid><description>&lt;p>The ephemeral nature of containers and serverless functions introduces unique security challenges that traditional application security models weren&amp;rsquo;t designed to address. Unlike long-running virtual machines or physical servers, these workloads exist for minutes, hours, or even seconds, making traditional security monitoring and patching strategies ineffective. This fundamental shift requires a new approach to security that embraces the transient nature of these workloads while maintaining robust protection against evolving threats.&lt;/p>
&lt;p>Container and serverless security operates on the principle that protection must be built into the deployment pipeline rather than applied after deployment. This shift-left approach ensures that security controls are embedded throughout the development lifecycle, from image creation to runtime execution. The challenge lies in balancing security rigor with the speed and agility that containerized and serverless architectures promise to deliver.&lt;/p></description></item></channel></rss>