<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cloud Architecture Patterns on Scott Obert</title><link>https://scottobert.com/series/cloud-architecture-patterns/</link><description>Recent content in Cloud Architecture Patterns on Scott Obert</description><generator>Hugo</generator><language>en</language><copyright>&amp;copy;2022 Scott Obert</copyright><lastBuildDate>Sun, 11 Apr 2021 09:00:00 -0500</lastBuildDate><atom:link href="https://scottobert.com/series/cloud-architecture-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Real-time Processing Architectures</title><link>https://scottobert.com/posts/real-time-processing-architectures/</link><pubDate>Sun, 11 Apr 2021 09:00:00 -0500</pubDate><guid>https://scottobert.com/posts/real-time-processing-architectures/</guid><description>&lt;p>Real-time processing architectures address the fundamental challenge of extracting actionable insights from continuously flowing data streams while maintaining low latency and high throughput requirements. Unlike batch processing systems that operate on static datasets with relaxed timing constraints, real-time systems must process events as they arrive, often within milliseconds or seconds of generation. This temporal sensitivity introduces unique design considerations around event ordering, backpressure handling, and state management that distinguish real-time architectures from their batch-oriented counterparts.&lt;/p></description></item><item><title>Data Lake Architecture with AWS</title><link>https://scottobert.com/posts/data-lake-architecture-aws/</link><pubDate>Sun, 21 Mar 2021 09:00:00 -0500</pubDate><guid>https://scottobert.com/posts/data-lake-architecture-aws/</guid><description>&lt;p>Data lake architectures represent a fundamental departure from traditional data warehousing approaches, embracing schema-on-read principles and polyglot storage strategies that accommodate the velocity, variety, and volume characteristics of modern data ecosystems. Unlike data warehouses that require upfront schema definition and ETL processes to conform data to predefined structures, data lakes preserve raw data in its native format while providing flexible analysis capabilities that adapt to evolving analytical requirements. AWS provides a comprehensive suite of services that enable sophisticated data lake implementations while managing the operational complexity traditionally associated with big data platforms.&lt;/p></description></item><item><title>Resilience Engineering: Building Fault-Tolerant Systems</title><link>https://scottobert.com/posts/resilience-engineering-building-fault-tolerant-systems/</link><pubDate>Sun, 28 Feb 2021 09:00:00 -0500</pubDate><guid>https://scottobert.com/posts/resilience-engineering-building-fault-tolerant-systems/</guid><description>&lt;p>Resilience engineering represents a paradigm shift from trying to prevent all failures to designing systems that gracefully adapt and recover when failures inevitably occur. Traditional approaches focused on eliminating failure modes through redundancy and robust design, but complex distributed systems exhibit emergent behaviors that cannot be fully predicted or prevented. Instead, resilient systems embrace failure as a normal operating condition and build adaptive capabilities that maintain essential functions even under adverse conditions.&lt;/p></description></item><item><title>Distributed System Design Patterns in AWS</title><link>https://scottobert.com/posts/distributed-system-design-patterns/</link><pubDate>Sun, 07 Feb 2021 09:00:00 -0500</pubDate><guid>https://scottobert.com/posts/distributed-system-design-patterns/</guid><description>&lt;p>Distributed systems present unique challenges that require thoughtful application of proven design patterns to achieve reliability, scalability, and maintainability. Unlike monolithic applications where components communicate through in-process method calls, distributed systems must handle network partitions, variable latency, and partial failures as fundamental aspects of their operation. The patterns that emerge from these constraints form the foundation of robust cloud architectures, particularly when implemented using AWS&amp;rsquo;s managed services ecosystem.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-circuit-breaker" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-circuit-breaker" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">🔍&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-circuit-breaker");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-circuit-breaker");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml Circuit Breaker Pattern\n!define AWSPuml https:\/\/raw.githubusercontent.com\/awslabs\/aws-icons-for-plantuml\/v14.0\/dist\n!include AWSPuml\/AWSCommon.puml\n!include AWSPuml\/Compute\/Lambda.puml\n!include AWSPuml\/Database\/DynamoDBTable.puml\n!include AWSPuml\/ApplicationIntegration\/APIGateway.puml\n!include AWSPuml\/ApplicationIntegration\/SimpleQueueServiceQueue.puml\n!include AWSPuml\/ApplicationIntegration\/SimpleNotificationServiceTopic.puml\n\nskinparam BackgroundColor transparent\nskinparam componentStyle rectangle\nskinparam defaultTextAlignment center\n\npackage \u0022Circuit Breaker Pattern Implementation\u0022 {\n component \u0022API Gateway\u0022 as api #LightBlue\n component \u0022Lambda Function\u0022 as lambda #LightBlue\n component \u0022Circuit Breaker State\u0022 as state #Orange\n database \u0022DynamoDB\u0022 as dynamodb #LightGreen\n component \u0022External Service\u0022 as external #Pink\n queue \u0022Fallback Queue\u0022 as fallbackQueue #LightYellow\n component \u0022SNS Notification\u0022 as notification #LightCyan\n}\n\nnote right of state\nStates:\n\n- Closed: Normal operation\n- Open: Failing fast\n- Half-Open: Testing recovery\nend note\n\napi --\u003e lambda : 1. Client Request\nlambda --\u003e state : 2. Check circuit state\nstate --\u003e dynamodb : 3. Read\/Update state\nstate -\u003e external : 4a. If Closed\/Half-Open: Call service\nstate --\u003e fallbackQueue : 4b. If Open: Use fallback\nexternal --\u003e state : 5. Update success\/failure count\nstate --\u003e notification : 6. Circuit state change notification\n\nnote bottom of lambda\nTracks:\n\n- Failure count\n- Error threshold\n- Reset timeout\n- Last failure timestamp\nend note\n\n@enduml\n")
&lt;/script>
&lt;p>The Circuit Breaker pattern addresses one of the most common failure modes in distributed systems: cascading failures caused by unhealthy dependencies. When a downstream service becomes unresponsive, continuing to send requests not only wastes resources but can propagate the failure upstream. A circuit breaker monitors failure rates and response times, automatically switching to an open state when thresholds are exceeded. AWS Application Load Balancer&amp;rsquo;s health checking mechanisms provide a managed implementation of this pattern, automatically removing unhealthy targets from rotation and gradually reintroducing them as they recover.&lt;/p></description></item><item><title>CQRS Implementation with AWS Services</title><link>https://scottobert.com/posts/cqrs-implementation-aws-services/</link><pubDate>Sun, 17 Jan 2021 09:00:00 -0500</pubDate><guid>https://scottobert.com/posts/cqrs-implementation-aws-services/</guid><description>&lt;p>Command Query Responsibility Segregation represents a fundamental shift in how we think about data persistence and retrieval in distributed systems. Rather than treating reads and writes as symmetric operations against a single data model, CQRS acknowledges the inherent differences between these operations and optimizes each path independently. In the context of AWS services, this pattern becomes particularly powerful when we leverage the managed services ecosystem to handle the complexity of maintaining separate command and query models.&lt;/p></description></item><item><title>Event Sourcing Patterns in AWS</title><link>https://scottobert.com/posts/event-sourcing-patterns-aws/</link><pubDate>Sun, 27 Dec 2020 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/event-sourcing-patterns-aws/</guid><description>&lt;p>Event sourcing fundamentally changes how applications handle state management by storing every state change as an immutable event rather than maintaining current state snapshots. This architectural pattern becomes particularly powerful when implemented on AWS, where managed services provide the scalability and durability required for enterprise-grade event sourcing systems. Understanding how to leverage AWS services effectively for event sourcing can transform application architectures from brittle state-dependent systems into resilient, audit-friendly, and highly scalable solutions.&lt;/p></description></item><item><title>Multi-Account AWS Strategies for Enterprise Applications</title><link>https://scottobert.com/posts/multi-account-aws-strategies-enterprise-applications/</link><pubDate>Sun, 06 Dec 2020 11:00:00 -0700</pubDate><guid>https://scottobert.com/posts/multi-account-aws-strategies-enterprise-applications/</guid><description>&lt;p>Enterprise organizations face unique challenges when scaling their AWS infrastructure beyond simple single-account deployments. As applications grow in complexity and regulatory requirements become more stringent, the need for sophisticated multi-account strategies becomes paramount. This exploration delves into proven patterns that enable organizations to maintain security, compliance, and operational efficiency across distributed cloud environments.&lt;/p>
&lt;div class="plantuml-container">
 &lt;img id="plantuml-multi-account-architecture" class="plantuml-diagram"/>
 &lt;a id="plantuml-link-multi-account-architecture" href="#" target="_blank" class="plantuml-link" title="Open diagram in new window">
 &lt;span class="plantuml-link-icon">🔍&lt;/span>
 &lt;/a>
&lt;/div>
&lt;script src="https://scottobert.com/js/rawdeflate.js">&lt;/script>
&lt;script>
 

 function encode64(data) {
 r = "";
 for (i=0; i&lt;data.length; i+=3) {
 if (i+2==data.length) {
 r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
 } else if (i+1==data.length) {
 r += append3bytes(data.charCodeAt(i), 0, 0);
 } else {
 r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
 data.charCodeAt(i+2));
 }
 }
 return r;
 }

 function append3bytes(b1, b2, b3) {
 c1 = b1 >> 2;
 c2 = ((b1 &amp; 0x3) &lt;&lt; 4) | (b2 >> 4);
 c3 = ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 >> 6);
 c4 = b3 &amp; 0x3F;
 r = "";
 r += encode6bit(c1 &amp; 0x3F);
 r += encode6bit(c2 &amp; 0x3F);
 r += encode6bit(c3 &amp; 0x3F);
 r += encode6bit(c4 &amp; 0x3F);
 return r;
 }

 function encode6bit(b) {
 if (b &lt; 10) {
 return String.fromCharCode(48 + b);
 }
 b -= 10;
 if (b &lt; 26) {
 return String.fromCharCode(65 + b);
 }
 b -= 26;
 if (b &lt; 26) {
 return String.fromCharCode(97 + b);
 }
 b -= 26;
 if (b == 0) {
 return '-';
 }
 if (b == 1) {
 return '_';
 }
 return '?';
 }

 var deflater = window.SharedWorker &amp;&amp; new SharedWorker('/js/rawdeflate.js');
 if (deflater) {
 deflater.port.addEventListener('message', done_deflating, false);
 deflater.port.start();
 } else if (window.Worker) {
 deflater = new Worker('/js/rawdeflate.js');
 deflater.onmessage = done_deflating;
 }

 function done_deflating(e) {
 const img = document.getElementById("plantuml-multi-account-architecture");
 const imgUrl = "https://www.plantuml.com/plantuml/img/"+encode64(e.data);
 img.src = imgUrl;
 
 
 const link = document.getElementById("plantuml-link-multi-account-architecture");
 if (link) {
 link.href = imgUrl;
 }
 }

 function compress(s) {
 
 s = unescape(encodeURIComponent(s));
 
 if (deflater) {
 if (deflater.port &amp;&amp; deflater.port.postMessage) {
 deflater.port.postMessage(s);
 } else {
 deflater.postMessage(s);
 }
 } else {
 setTimeout(function() {
 done_deflating({ data: deflate(s) });
 }, 100);
 }
 }

 compress("\n@startuml\n!theme aws-orange\ntitle Multi-Account AWS Architecture Pattern\n\npackage \u0022Management Account\u0022 {\n [AWS Organizations]\n [Consolidated Billing]\n [AWS SSO]\n [CloudTrail (Org)]\n}\n\npackage \u0022Security Account\u0022 {\n [GuardDuty Master]\n [Security Hub]\n [Config Aggregator]\n [CloudTrail Logs]\n}\n\npackage \u0022Production Account\u0022 {\n [Application Services]\n [RDS Production]\n [S3 Production]\n}\n\npackage \u0022Development Account\u0022 {\n [Dev Services]\n [RDS Dev]\n [S3 Dev]\n}\n\npackage \u0022Shared Services Account\u0022 {\n [Transit Gateway]\n [DNS Resolution]\n [Centralized Logging]\n}\n\n[AWS Organizations] --\u003e [Security Account]\n[AWS Organizations] --\u003e [Production Account]\n[AWS Organizations] --\u003e [Development Account]\n[AWS Organizations] --\u003e [Shared Services Account]\n\n[Transit Gateway] --\u003e [Production Account]\n[Transit Gateway] --\u003e [Development Account]\n\n@enduml\n")
&lt;/script>
&lt;h2 id="understanding-the-multi-account-imperative">Understanding the Multi-Account Imperative&lt;/h2>
&lt;p>The traditional approach of housing all resources within a single AWS account quickly becomes untenable for enterprise applications. Security boundaries blur when development, staging, and production workloads share the same account, creating unnecessary risk exposure. Compliance frameworks often mandate strict separation of environments, making single-account architectures insufficient for regulated industries.&lt;/p></description></item></channel></rss>